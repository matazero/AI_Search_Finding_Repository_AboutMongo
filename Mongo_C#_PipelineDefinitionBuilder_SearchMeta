What SearchMeta Does:

Returns metadata about search results (counts, facets, distributions) without returning actual documents
Much faster than retrieving full documents when you only need statistics
Useful for building search UIs with filters, counts, and facet navigation

Examples Provided:

Basic Count - Get total matching documents count
Faceted Search - Get distribution of results by ParentId
Multiple Facets - Combine different facet types in one query
Autocomplete Metadata - Count matches for autocomplete scenarios

Key Components:
SearchMeta Parameters:

searchDefinition - Your search query (text, autocomplete, compound, etc.)
indexName - Atlas Search index name (must be created in Atlas first)
SearchCountOptions - Total or LowerBound count type
facets - Array of facet definitions for grouping results

Critical Setup Requirement:
⚠️ You MUST create an Atlas Search Index first - SearchMeta only works with MongoDB Atlas Search. The artifact includes the JSON configuration you need to create the index in your Atlas dashboard.
Would you like me to add more specific examples, like combining SearchMeta with regular search results, or examples with date range facets?RetryMWhat is SearchMeta used forEditSearchMeta is used for getting metadata and statistics about search results WITHOUT retrieving the actual documents. Think of it as asking "tell me about the results" instead of "give me the results."
Main Use Cases:
1. Getting Result Counts

"How many categories match 'electronics'?" → Returns just the number, not 10,000 documents
Much faster and cheaper than counting documents after retrieving them

2. Building Search Facets/Filters (Most Common Use)
Like on e-commerce sites:
Search: "laptop"
└─ Brands (facet)
   ├─ Dell (127 results)
   ├─ HP (94 results)
   └─ Lenovo (88 results)
└─ Price Range (facet)
   ├─ $0-500 (45 results)
   ├─ $500-1000 (156 results)
   └─ $1000+ (108 results)
In your case:
Search: "phone accessories"
└─ Parent Categories (facet)
   ├─ Electronics (234 matches)
   ├─ Mobile Devices (189 matches)
   └─ Accessories (156 matches)
3. Search Analytics

"Which categories are most popular in search?"
"What's the distribution of search results?"
Building dashboards without loading all data

4. Autocomplete Feedback
User types: "elec..."
SearchMeta returns: "12 matches found" 
(Shows count before user even selects from dropdown)
Why Not Just Count Documents Normally?
Without SearchMeta:
csharpvar results = await _collection.Find(filter).ToListAsync(); // Gets ALL documents
var count = results.Count; // Slow, expensive, uses memory
With SearchMeta:
csharpvar count = await GetSearchCountAsync("electronics"); // Just gets the number
// Fast, efficient, no documents transferred
Real-World Example:
Imagine Amazon's search:

User searches "wireless mouse"
SearchMeta instantly returns:

Total: 3,847 products
Brands: Logitech (523), Microsoft (412), Razer (289)...
Price ranges: $0-20 (1,245), $20-50 (1,890)...


User sees filters immediately
Only when user clicks page 1, actual products load

The key benefit: You get insights about search results without the performance cost of retrieving thousands of documents you don't need yet.

##############################
   CODE    CODE     CODE 
##############################
// ============================================
// 1. CONTROLLER - Add SearchMeta endpoints
// ============================================

[ApiController]
[Route("api/[controller]")]
public class CategoryController : Controller
{
    private readonly CategoryService _categoryService;
    
    public CategoryController(CategoryService categoryService)
    {
        _categoryService = categoryService;
    }

    // Get search metadata with facets
    [HttpGet("search/meta/facets")]
    public async Task<IActionResult> GetSearchMetaWithFacets([FromQuery] string searchTerm)
    {
        var metadata = await _categoryService.GetSearchMetadataWithFacetsAsync(searchTerm);
        return Ok(metadata);
    }

    // Get count of matching documents
    [HttpGet("search/meta/count")]
    public async Task<IActionResult> GetSearchCount([FromQuery] string searchTerm)
    {
        var result = await _categoryService.GetSearchCountAsync(searchTerm);
        return Ok(result);
    }

    // Get search metadata with multiple facets
    [HttpGet("search/meta/detailed")]
    public async Task<IActionResult> GetDetailedSearchMeta([FromQuery] string searchTerm)
    {
        var metadata = await _categoryService.GetDetailedSearchMetadataAsync(searchTerm);
        return Ok(metadata);
    }

    // Get autocomplete metadata
    [HttpGet("search/meta/autocomplete")]
    public async Task<IActionResult> GetAutocompleteMeta([FromQuery] string prefix)
    {
        var metadata = await _categoryService.GetAutocompleteMetadataAsync(prefix);
        return Ok(metadata);
    }
}

// ============================================
// 2. SERVICE - SearchMeta implementation methods
// ============================================

public class CategoryService : MongoDbRepository<Category>
{
    public CategoryService(IOptions<DatabaseSettings> databaseSettings) : base(databaseSettings)
    {
    }

    /// <summary>
    /// Gets search metadata with facet information about categories
    /// This returns metadata about the search without returning actual documents
    /// </summary>
    public async Task<BsonDocument> GetSearchMetadataWithFacetsAsync(string searchTerm)
    {
        // Build the $searchMeta stage using BsonDocument
        var searchMetaStage = new BsonDocument
        {
            {
                "$searchMeta", new BsonDocument
                {
                    { "index", "default" }, // Your Atlas Search index name
                    { 
                        "text", new BsonDocument
                        {
                            { "query", searchTerm },
                            { "path", "Name" }
                        }
                    },
                    {
                        "count", new BsonDocument
                        {
                            { "type", "total" }
                        }
                    },
                    {
                        "facet", new BsonDocument
                        {
                            {
                                "operator", new BsonDocument
                                {
                                    {
                                        "text", new BsonDocument
                                        {
                                            { "query", searchTerm },
                                            { "path", "Name" }
                                        }
                                    }
                                }
                            },
                            {
                                "facets", new BsonDocument
                                {
                                    {
                                        "categoriesByParent", new BsonDocument
                                        {
                                            { "type", "string" },
                                            { "path", "ParentId" },
                                            { "numBuckets", 50 }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        // Create pipeline with the stage
        var pipeline = new[] { searchMetaStage };

        // Execute aggregation
        var results = await _collection.Aggregate<BsonDocument>(pipeline).ToListAsync();
        
        return results.FirstOrDefault();
    }

    /// <summary>
    /// Gets the total count of documents matching the search query
    /// Simple count without facets
    /// </summary>
    public async Task<BsonDocument> GetSearchCountAsync(string searchTerm)
    {
        var searchMetaStage = new BsonDocument
        {
            {
                "$searchMeta", new BsonDocument
                {
                    { "index", "default" },
                    { 
                        "text", new BsonDocument
                        {
                            { "query", searchTerm },
                            { "path", "Name" }
                        }
                    },
                    {
                        "count", new BsonDocument
                        {
                            { "type", "total" }
                        }
                    }
                }
            }
        };

        var pipeline = new[] { searchMetaStage };

        var result = await _collection.Aggregate<BsonDocument>(pipeline).FirstOrDefaultAsync();
        
        return result;
    }

    /// <summary>
    /// Gets detailed search metadata including count and multiple facets
    /// </summary>
    public async Task<BsonDocument> GetDetailedSearchMetadataAsync(string searchTerm)
    {
        var searchMetaStage = new BsonDocument
        {
            {
                "$searchMeta", new BsonDocument
                {
                    { "index", "default" },
                    { 
                        "text", new BsonDocument
                        {
                            { "query", searchTerm },
                            { "path", "Name" }
                        }
                    },
                    {
                        "count", new BsonDocument
                        {
                            { "type", "total" }
                        }
                    },
                    {
                        "facet", new BsonDocument
                        {
                            {
                                "operator", new BsonDocument
                                {
                                    {
                                        "text", new BsonDocument
                                        {
                                            { "query", searchTerm },
                                            { "path", "Name" }
                                        }
                                    }
                                }
                            },
                            {
                                "facets", new BsonDocument
                                {
                                    {
                                        "byParent", new BsonDocument
                                        {
                                            { "type", "string" },
                                            { "path", "ParentId" },
                                            { "numBuckets", 100 }
                                        }
                                    },
                                    {
                                        "byDescription", new BsonDocument
                                        {
                                            { "type", "string" },
                                            { "path", "Description" },
                                            { "numBuckets", 50 }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        var pipeline = new[] { searchMetaStage };
        
        var result = await _collection.Aggregate<BsonDocument>(pipeline).FirstOrDefaultAsync();
        
        return result;
    }

    /// <summary>
    /// Get search metadata for autocomplete scenarios
    /// Returns count without facets
    /// </summary>
    public async Task<BsonDocument> GetAutocompleteMetadataAsync(string prefix)
    {
        var searchMetaStage = new BsonDocument
        {
            {
                "$searchMeta", new BsonDocument
                {
                    { "index", "default" },
                    { 
                        "autocomplete", new BsonDocument
                        {
                            { "query", prefix },
                            { "path", "Name" },
                            { 
                                "fuzzy", new BsonDocument
                                {
                                    { "maxEdits", 1 }
                                }
                            }
                        }
                    },
                    {
                        "count", new BsonDocument
                        {
                            { "type", "total" }
                        }
                    }
                }
            }
        };

        var pipeline = new[] { searchMetaStage };

        var result = await _collection.Aggregate<BsonDocument>(pipeline).FirstOrDefaultAsync();

        return result;
    }

    /// <summary>
    /// Advanced: Compound search with multiple conditions
    /// </summary>
    public async Task<BsonDocument> GetCompoundSearchMetadataAsync(string nameQuery, string descriptionQuery)
    {
        var searchMetaStage = new BsonDocument
        {
            {
                "$searchMeta", new BsonDocument
                {
                    { "index", "default" },
                    {
                        "compound", new BsonDocument
                        {
                            {
                                "must", new BsonArray
                                {
                                    new BsonDocument
                                    {
                                        {
                                            "text", new BsonDocument
                                            {
                                                { "query", nameQuery },
                                                { "path", "Name" }
                                            }
                                        }
                                    }
                                }
                            },
                            {
                                "should", new BsonArray
                                {
                                    new BsonDocument
                                    {
                                        {
                                            "text", new BsonDocument
                                            {
                                                { "query", descriptionQuery },
                                                { "path", "Description" }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    {
                        "count", new BsonDocument
                        {
                            { "type", "total" }
                        }
                    },
                    {
                        "facet", new BsonDocument
                        {
                            {
                                "operator", new BsonDocument
                                {
                                    {
                                        "text", new BsonDocument
                                        {
                                            { "query", nameQuery },
                                            { "path", "Name" }
                                        }
                                    }
                                }
                            },
                            {
                                "facets", new BsonDocument
                                {
                                    {
                                        "byParent", new BsonDocument
                                        {
                                            { "type", "string" },
                                            { "path", "ParentId" }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        var pipeline = new[] { searchMetaStage };

        return await _collection.Aggregate<BsonDocument>(pipeline).FirstOrDefaultAsync();
    }

    /// <summary>
    /// Helper method to extract count from BsonDocument result
    /// </summary>
    public long ExtractCountFromResult(BsonDocument result)
    {
        if (result != null && result.Contains("count"))
        {
            var countDoc = result["count"].AsBsonDocument;
            if (countDoc.Contains("total"))
            {
                return countDoc["total"].ToInt64();
            }
            if (countDoc.Contains("lowerBound"))
            {
                return countDoc["lowerBound"].ToInt64();
            }
        }
        return 0;
    }

    /// <summary>
    /// Helper method to extract facet buckets from result
    /// </summary>
    public List<FacetBucket> ExtractFacetBuckets(BsonDocument result, string facetName)
    {
        var buckets = new List<FacetBucket>();

        if (result != null && result.Contains("facet"))
        {
            var facetDoc = result["facet"].AsBsonDocument;
            if (facetDoc.Contains(facetName))
            {
                var facetData = facetDoc[facetName].AsBsonDocument;
                if (facetData.Contains("buckets"))
                {
                    var bucketsArray = facetData["buckets"].AsBsonArray;
                    foreach (var bucket in bucketsArray)
                    {
                        var bucketDoc = bucket.AsBsonDocument;
                        buckets.Add(new FacetBucket
                        {
                            Id = bucketDoc.Contains("_id") ? bucketDoc["_id"].ToString() : null,
                            Count = bucketDoc.Contains("count") ? bucketDoc["count"].ToInt64() : 0
                        });
                    }
                }
            }
        }

        return buckets;
    }
}

// ============================================
// 3. MODELS - Support classes
// ============================================

public class FacetBucket
{
    public string Id { get; set; }
    public long Count { get; set; }
}

// ============================================
// 4. USAGE EXAMPLES
// ============================================

/*
EXAMPLE RESPONSES:

1. GetSearchCountAsync("electronics") returns:
{
  "count": {
    "total": 234
  }
}

2. GetSearchMetadataWithFacetsAsync("phone") returns:
{
  "count": {
    "total": 156
  },
  "facet": {
    "categoriesByParent": {
      "buckets": [
        { "_id": "64abc123def456", "count": 89 },
        { "_id": "64abc789ghi012", "count": 67 }
      ]
    }
  }
}

3. GetDetailedSearchMetadataAsync("laptop") returns:
{
  "count": {
    "total": 421
  },
  "facet": {
    "byParent": {
      "buckets": [
        { "_id": "64abc111", "count": 200 },
        { "_id": "64abc222", "count": 150 },
        { "_id": "64abc333", "count": 71 }
      ]
    },
    "byDescription": {
      "buckets": [
        { "_id": "gaming", "count": 120 },
        { "_id": "business", "count": 180 },
        { "_id": "student", "count": 121 }
      ]
    }
  }
}

TO USE IN YOUR CONTROLLER:
var result = await _categoryService.GetSearchCountAsync("electronics");
long totalCount = _categoryService.ExtractCountFromResult(result);

var facetResult = await _categoryService.GetSearchMetadataWithFacetsAsync("phone");
var parentBuckets = _categoryService.ExtractFacetBuckets(facetResult, "categoriesByParent");
*/

// ============================================
// 5. ATLAS SEARCH INDEX CONFIGURATION
// ============================================

/*
STEP 1: Create Search Index in MongoDB Atlas

1. Go to Atlas Dashboard → Your Cluster → Search tab
2. Click "Create Search Index"
3. Choose JSON Editor
4. Use this configuration:

BASIC INDEX (for text search):
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "Name": {
        "type": "string",
        "analyzer": "lucene.standard"
      },
      "ParentId": {
        "type": "string"
      },
      "Description": {
        "type": "string",
        "analyzer": "lucene.standard"
      }
    }
  }
}

ADVANCED INDEX (with autocomplete):
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "Name": [
        {
          "type": "string",
          "analyzer": "lucene.standard"
        },
        {
          "type": "autocomplete",
          "analyzer": "lucene.standard",
          "tokenization": "edgeGram",
          "minGrams": 2,
          "maxGrams": 15,
          "foldDiacritics": true
        }
      ],
      "ParentId": {
        "type": "string"
      },
      "Description": {
        "type": "string",
        "analyzer": "lucene.standard"
      }
    }
  }
}

5. Name your index "default"
6. Select your database and "Category" collection
7. Click "Create Search Index"
8. Wait 1-2 minutes for index to build

STEP 2: Test with sample data
Insert some test categories:
db.Category.insertMany([
  { Name: "Electronics", ParentId: null, Description: "Electronic devices" },
  { Name: "Phones", ParentId: "electronics_id", Description: "Mobile phones" },
  { Name: "Laptops", ParentId: "electronics_id", Description: "Portable computers" }
])

STEP 3: Test the API endpoints
GET /api/category/search/meta/count?searchTerm=phone
GET /api/category/search/meta/facets?searchTerm=electronics
GET /api/category/search/meta/detailed?searchTerm=laptop
*/
